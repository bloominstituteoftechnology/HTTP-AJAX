{"ast":null,"code":"/*!\n * VERSION: 0.0.4\n * DATE: 2018-05-30\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n */\nimport { _gsScope } from \"./TweenLite.js\";\n\nvar _cssRatioSetter = function _cssRatioSetter(pt, cssp, mod) {\n  //Takes an individual CSSPropTween and converts it into a type:2 that has a setRatio that does everything the regular CSSPlugin.setRatio() method does but applying the mod() too. We do this to keep the main CSSPlugin.setRatio() as fast as possible (the vast majority of times, no mod() will be necessary)\n  var type = pt.type,\n      oldSetRatio = pt.setRatio,\n      tween = cssp._tween,\n      target = cssp._target;\n  pt.type = 2;\n  pt.m = mod;\n\n  pt.setRatio = function (v) {\n    var min = 0.000001,\n        val,\n        str,\n        i;\n\n    if (v === 1 && (tween._time === tween._duration || tween._time === 0)) {\n      if (type !== 2) {\n        if (pt.r && type !== -1) {\n          val = Math.round(pt.s + pt.c);\n\n          if (!type) {\n            pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);\n          } else if (type === 1) {\n            str = pt.xs0 + val + pt.xs1;\n\n            for (i = 1; i < pt.l; i++) {\n              str += pt[\"xn\" + i] + pt[\"xs\" + (i + 1)];\n            }\n\n            pt.t[pt.p] = mod.call(tween, str, target, tween);\n          }\n        } else {\n          pt.t[pt.p] = mod.call(tween, pt.e, target, tween);\n        }\n      } else {\n        oldSetRatio.call(pt, v);\n      }\n    } else if (v || !(tween._time === tween._duration || tween._time === 0) || tween._rawPrevTime === -0.000001) {\n      val = pt.c * v + pt.s;\n\n      if (pt.r) {\n        val = Math.round(val);\n      } else if (val < min) if (val > -min) {\n        val = 0;\n      }\n\n      if (!type) {\n        pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);\n      } else if (type === 1) {\n        str = pt.xs0 + val + pt.xs1;\n\n        for (i = 1; i < pt.l; i++) {\n          str += pt[\"xn\" + i] + pt[\"xs\" + (i + 1)];\n        }\n\n        pt.t[pt.p] = mod.call(tween, str, target, tween);\n      } else if (type === -1) {\n        //non-tweening value\n        pt.t[pt.p] = mod.call(tween, pt.xs0, target, tween);\n      } else if (oldSetRatio) {\n        oldSetRatio.call(pt, v);\n      }\n    } else {\n      if (type !== 2) {\n        pt.t[pt.p] = mod.call(tween, pt.b, target, tween);\n      } else {\n        oldSetRatio.call(pt, v);\n      }\n    }\n  };\n},\n    _modCSS = function _modCSS(lookup, cssp) {\n  var pt = cssp._firstPT,\n      hasBezier = lookup.rotation && cssp._overwriteProps.join(\"\").indexOf(\"bezier\") !== -1; //when a Bezier tween is applying autoRotation, it's a very special case we need to handle differently.\n\n  if (lookup.scale) {\n    lookup.scaleX = lookup.scaleY = lookup.scale;\n  } else if (lookup.rotationZ) {\n    lookup.rotation = lookup.rotationZ;\n  }\n\n  while (pt) {\n    if (typeof lookup[pt.p] === \"function\") {\n      _cssRatioSetter(pt, cssp, lookup[pt.p]);\n    } else if (hasBezier && pt.n === \"bezier\" && pt.plugin._overwriteProps.join(\"\").indexOf(\"rotation\") !== -1) {\n      pt.data.mod = lookup.rotation;\n    }\n\n    pt = pt._next;\n  }\n},\n    ModifiersPlugin = _gsScope._gsDefine.plugin({\n  propName: \"modifiers\",\n  version: \"0.0.4\",\n  API: 2,\n  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n  init: function init(target, value, tween) {\n    this._tween = tween;\n    this._vars = value;\n    return true;\n  },\n  initAll: function initAll() {\n    var tween = this._tween,\n        lookup = this._vars,\n        mpt = this,\n        pt = tween._firstPT,\n        val,\n        next; //initAll() gets called for each and every ModifiersPlugin instance in a tween, so if there are multiple targets, there will be multiple instances. Since we're ripping through the whole tween (and all the PropTweens), we only need to run this code ONCE. So we're setting a toggle on the first PropTween that just tells us if we've done it already. We don't set it on the tween instance because if it gets invalidated, we don't want to have to track this property and reset it. PropTweens get blown away when a tween is invalidated.\n\n    if (pt._modInitted) {\n      return false;\n    } else {\n      pt._modInitted = 1;\n    }\n\n    while (pt) {\n      next = pt._next; //record here, because it may get removed\n\n      val = lookup[pt.n];\n\n      if (pt.pg) {\n        if (pt.t._propName === \"css\") {\n          //handle CSSPlugin uniquely (for performance, due to the fact that the values almost always are a concatenation of numbers and strings, like suffixes, and we don't want to slow down the regular CSSPlugin setRatio() performance with conditional checks for if the value needs to be modded, so we pull any modding prop out and change it to a type:2 one that simply calls a setRatio() method where we encapsulate the modding and update all together. That way, it says in the main CSSProp linked list and just has some custom logic applied to it inside its setRatio())\n          _modCSS(lookup, pt.t);\n        } else if (pt.t !== mpt) {\n          //don't run modProps on modProps :)\n          val = lookup[pt.t._propName];\n          pt.t._tween = tween;\n\n          pt.t._mod(typeof val === \"object\" ? val : lookup);\n        }\n      } else if (typeof val === \"function\") {\n        if (pt.f === 2 && pt.t) {\n          //a blob (text containing multiple numeric values)\n          pt.t._applyPT.m = val;\n          pt.t._tween = tween;\n        } else {\n          this._add(pt.t, pt.p, pt.s, pt.c, val); //remove from linked list\n\n\n          if (next) {\n            next._prev = pt._prev;\n          }\n\n          if (pt._prev) {\n            pt._prev._next = next;\n          } else if (tween._firstPT === pt) {\n            tween._firstPT = next;\n          }\n\n          pt._next = pt._prev = null;\n          tween._propLookup[pt.n] = mpt;\n        }\n      }\n\n      pt = next;\n    }\n\n    return false;\n  }\n}),\n    p = ModifiersPlugin.prototype;\n\np._add = function (target, p, s, c, mod) {\n  this._addTween(target, p, s, s + c, p, mod);\n\n  this._overwriteProps.push(p);\n};\n\np = _gsScope._gsDefine.globals.TweenLite.version.split(\".\");\n\nif (Number(p[0]) <= 1 && Number(p[1]) < 19 && _gsScope.console) {\n  console.log(\"ModifiersPlugin requires GSAP 1.19.0 or later.\");\n}\n\nexport { ModifiersPlugin, ModifiersPlugin as default };","map":null,"metadata":{},"sourceType":"module"}